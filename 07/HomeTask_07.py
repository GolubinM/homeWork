from random import randint

print("\n\nЗадание 1. Расставить по росту.")
# Решение:
# Генерируем список каждый элемент которого имеет структуру (рост, имя) (list_height[el[0]], el[1])
# Сортируем сгенерированный список. Сортировка проходит по первому элементу(рост) каждого эл-та списка
# Генерируем новый список только из имен (элемент с индексом 1(name[1]) каждого эл-та списка). Форматируем, выводим.

list_names = ['Адриан', 'Флорентин', 'Олимпий', 'Андроник', 'Лев', 'Мечислав', 'Эдуард', 'Самсон', 'Данила', 'Азарий']
list_height = list(randint(165, 190) for _ in range(len(list_names)))
print("Не сортированный по росту список:")
print(*(f"{elm:^10}" for elm in list_names))
print(*(f"{elm:^10}" for elm in list_height))
# Решение:
sort_list = [name[1] for name in sorted([(list_height[el[0]], el[1]) for el in enumerate(list_names)], reverse=True)]
print("Отсортированный по убыванию роста список имен:")
print(*(f"{elm:^10}" for elm in sort_list))

# =====================================================================

print("\n\nЗадание 2. Хорошие пары.")
# Дан одномерный массив целых чисел nums. Вернуть количество хороших пар
# где хорошая пара удовлетворяет условию num[i] == num[j] и i < j
# Решение
# Фактически, задача состоит в вычислении суммы членов арифметической прогрессии от 1 до (кол-ва схожих эл-в - 1)
# 1. Создаем массив случайных чисел длинной 30, числа в диапазоне от 0 до 10
# 2. Сортируем массив для упрощения последующей очистки срезами
# 3. Находим для первого элемента массива количество равных
#    по значению эл-ов массива, если количество схожих элементов > 1
#    вычисляем good_pair для данного элемента массива(сумма членов арифм прогрессии от (кол-ва - 1) схожих эл-ов)
#    good_pair = (count_elms**2-count_elms)/2, суммируем значение в счетчик total_good_pair.
# 3. Удаляем все элементы(из п.3) с посчитанными парами
# 4. Возвращаемся к шагу 3. и так пока длинна массива > 1

min_value = 0
max_value = 10
len_arr = 30
array_1 = list(randint(min_value, max_value) for _ in range(len_arr))
print(array_1)
# Решение:
array_1.sort()  # сортируем для удобства последующей очистки списка по срезу(быстрее фильтрации на 30%)
total_good_pair = 0
print("Числа с хорошими парами:")
print(f"{'число':^10}{'кол-во в массиве':^20}{'хороших пар':^10}")
while len(array_1) > 1:
    groom = array_1[0]
    count_elms = array_1.count(groom)
    if count_elms > 1:
        # результат всегда целое, поэтому оператор целочисленного деления, чтобы не преобразовывать в int
        good_pair = (count_elms ** 2 - count_elms) // 2
        total_good_pair += good_pair
        print(f"{groom:^10}{count_elms:^20}{good_pair:^10}")
    del array_1[:count_elms]
print("-" * 40, f"\nВсего хороших пар: {total_good_pair:^32}")

# =====================================================================
print("\n\nЗадание 3. Сколько чисел в массиве меньше num[i].")
nums = [randint(0, 10) for _ in range(5)]
print("nums =", nums)
out_nums = [sum(1 for j in nums if i > j) for i in nums]
print("Вывод:", out_nums)
