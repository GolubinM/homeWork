MENUC = '\033[93m'
ENDC = '\033[0m'  # цвета для меню
# ==================================================================================
print("Модуль 4. Строки. Списки. Часть 1")
print("Задание 1. Является ли введенная строка палиндромом?")


# 0. Циклом обходим примеры с образцами строк
# 1. Отбираем итератором из строки только буквы
# 2. Обращаем все в нижний регистр и объединяем в строку alpha_string
# 3. Сравнивем срез в обратном направлении string_1 с переменной string_1
def is_polyndrom(test_str):
    alpha_string = "".join([*(symbol.casefold() for symbol in test_str if symbol.isalpha())])
    answer = "" if alpha_string == alpha_string[::-1] else "не "
    return f'{MENUC}\tСтрока{ENDC} "{test_str}" {MENUC}{answer}является палиндромом.{ENDC}'


test_string = []
while True:
    string_1 = input(f"{MENUC}Введите строку для проверки - является ли она палиндромом:\n"
                     "(Enter - будет использована строка по-умолчанию)\n"
                     f"Для выхода введите 0: {ENDC}")
    if string_1 == "0":
        print("Good buy!")
        break
    elif string_1 == "":
        test_strings = ["кок", "А роза упала на лапу Азора", "А вторая роза упала на лапу Азора", "доход",
                        "А буду я у дуба", "А буду я у дуба в Абу-Даби"]
        print("Будет использован набор строк по-умолчанию.")
    else:
        test_strings = [string_1]
    for test_str in test_strings:
        print(is_polyndrom(test_str))
# ==================================================================================

print("\nЗадание 2. Пользователь вводит с клавиатуры некоторый текст, после чего пользователь вводит список "
      "зарезервированных слов. \nИзменить регистр зарезервированных слов в предлжении на верхний")
# 0. Уточняем условие задачи: Пользователь вводит список слов в любом регистре, совпадения зарезервированных слов
#    проверяем без учета регистра символов
# 1. Копию строки в нижнем регистре сохраняем в переменную low_string
# 2. Зарезервированные слова помещаем в список words, проходим циклом по списку
# 3. Проверяем нет ли перед или после найденной субстроки символов алфавита(исключаем частичную замену другого слова)
string_1 = ""  # очищаем переменную из предыдущего задания
while True:
    string_1 = input(f"{MENUC}Введите строку с текстом\n(Enter - будет использована строка по-умолчанию)\n"
                     f"Для выхода введите 0: {ENDC}")
    if string_1 == "0":
        print("Good buy!")
        break
    elif string_1 == "":
        string_1 = "Палиндром — слово или текст, которое читается одинаково слева направо и справа налево. \n" \
                   "\"сЛЕВа\" наПраво читАЕТ ЗабАва, СПРАВА налевО \"читает\" Валера. \n" \
                   "СлОвО не воробей — когда-нибудь выстрелит."
        print(f"{MENUC}Для преобразования выбраны строки по-умолчанию:{ENDC}", string_1, sep="\n")
    words = input(f"{MENUC}Введите слова разделенные запятой, регистр этих слов в строке будет изменен на верхний\n"
                  f"(Enter - будет использован набор слов по-умолчанию): {ENDC}")
    if words == "":
        words = ("слово", "справа", "Забава", "слева", "ЧИТАЕТ", "вал")
        print(f"{MENUC}Установлены слова по-умолчанию:{ENDC}\n", ", ".join(*[words]), sep="")
    else:
        words = words.replace(" ", "")  # очищаем введенные пользователем слова от пробелов
        words = (words.split(","))  # разделяем введенные пользователем слова на элементы кортежа
    low_string = string_1.casefold()  # подготовка строки для сравнения (в нижний регистр)
    count = 0  # инициализация счетчика замен(для статистики)
    for word in words:
        word_lwr = word.casefold()  # подготовка слова для сравнения (в нижний регистр)
        length_word = len(word_lwr)  # определяем длину слова для вычисления индекса окончания слова в строке
        index = 0  # инициализация начального индекса поиска подстроки
        while True:
            index = low_string.find(word_lwr, index)  # ищем вхождение начиная с позиции index
            if index == -1:
                break  # искомого слова нет, выход, обработка следующего слова из кортежа words
            end_word = index + length_word  # вычисление индекса окончания слова в строке
            # проверка не является ли найденное вхождение частью более длинного слова, если нет - меняем регистр в string_1
            if string_1[:index].isalpha() or string_1[end_word:end_word + 1].isalpha() is not True:
                string_1 = string_1[:index] + string_1[index:end_word].upper() + string_1[end_word:]
                count += 1  # статистика замен
            index = end_word + 1  # вычисляем позицию начало поиска в оставшейся части строки
    print(f"{MENUC}Количество произведенных замен:{ENDC} {count}{MENUC}. \nРезультат замены:{ENDC}", string_1, sep="\n")

# ==================================================================================

import string

print("\nЗадание 3. Есть некоторый текст. Посчитайте в этом тексте количество предложений и выведите "
      "на экран полученный результат.")
# 1. Определяем критерии для поиска окончаний предложений
""" Знаки препинания, которые завершают предложение:
В конце предложения ставятся следующие знаки препинания:
      точка (.)
      вопросительный знак (?)
      восклицательный знак (!)
      многоточие (...). Этот знак ставится, когда высказывание не закончено.
      вопросительный и восклицательный знак (?!)
      вопросительный знак и многоточие (?...)
      восклицательный знак и многоточие (!...)
Не считаем окончанием предложения прямую речь, после которой закрываются кавычки и через пробел 
следует разделительный знак –(дефис). Пример:"«Далече ли до крепости?» – спросил я у своего ямщика."
т.е. следующие последовательности не конец предложения: "!\" -"; "?\" -"; "...\" -"; "?!\" -"; "?...\" -"; "!...\" -"
 (то же с кавычками » или ')
 (*) источники информации
http://gramota.ru/class/coach/punct/45_192?ysclid=lduh2nig94911367907
http://www.bolshoyvopros.ru/questions/108658-kakie-znaki-prepinanija-zavershajut-predlozhenija.html?ysclid=lduh951tfm780745994
"""
# 2. Создаем кортежи с набором последовательностей символов окончания предложения и символов "исключения"(не конец).
# 3. Удаляем из текста все непечатаемые символы для облегчения поиска признаков конца строк.
# 4. Удаляем из текста все последовательности "исключения", которые не означают завершения предложения.
# 5. Ищем количество вхождений для каждой последовательности окончания предложения и удаляем его чтобы не перепутать,
#    в зависимости от наполнения. Например: сперва удаляем многоточия, восклицательный знак с многоточием, затем точки.
# 6. Выводим значение счетчика окончаний предложений.
while True:
    text_1 = input(f"{MENUC}Введите текст с предложениями, которые нужно посчитать\n"
                   "(Enter - будет использован текст по-умолчанию): "
                   f"Для выхода введите 0: {ENDC}")
    if text_1 == "0":
        print("Good buy!")
        break
    elif text_1 == "":
        print(f"{MENUC}Будет использован текст по-умолчанию{ENDC}")
        text_1 = "«Далече ли до крепости?»\n\t – спросил я у своего ямщика. " \
                 "\"Далече ли до крепости?\" – спросил я у своего ямщика.\n" \
                 "'Далече ли до крепости?' – спросил я у своего ямщика.\n" \
                 "Старый священник подошел ко мне с вопросом: «Прикажете начинать?»\n" \
                 "«Тише, – говорит она мне, – отец болен, при смерти, и желает с тобою проститься» (Пушкин).\n" \
                 "Вперед не суйся, сзади не оставайся, в середине не болтайся!...\n" \
                 "А-а-а... Э-э-э... Того-самого... Я вот спросить хотел... " \
                 "Какие ошибки первыми бросаются в глаза?"

    # Маркеры конца предложений.
    finish = ("?...", "!...", "...", ".", "?!", "?", "!")
    # Маркеры исключений. В {0} будут подставлены различные виды кавычек. пробелы удалены, т.к. будут удалены в тексте.
    not_finish = ("!{0}–", "?{0}–", "...{0}–", "?!{0}–", "?...{0}–", "!...{0}–")
    quotation_marks = ("\"", "\'", "»")
    print(text_1)
    # Удаляем непечатаемые символы и пробелы (string.whitespace = ' \t\n\r\x0b\x0c')
    # (на случай непредвиденного разрыва последовательности маркеров)
    for symb in string.whitespace:
        text_1 = text_1.replace(symb, "")
    # Удаляем из текста все последовательности(маркеры) "исключения".
    for symb in not_finish:  # перебираем шаблоны маркеров
        for qout_mark in quotation_marks:  # перебираем кортеж с различными кавычками
            symb2 = symb.format(qout_mark)  # подставляем в шаблоны маркеров разные виды кавычек
            text_1 = text_1.replace(symb2, "")  # удаляем исключения(ложные окончания предложений)
    # подсчитываем окончания предложений поочередно удаляя каждый маркер
    count = 0  # Инициализация счетчика предлжений
    for symb in finish:  # перебираем шаблоны маркеров конца предложений
        while text_1.find(symb) != -1:  # пока находим маркер конец предложения - выполняем цикл
            text_1 = text_1.replace(symb, "", 1)  # удаляем окончания предложений по одному
            count += 1
    print(f"\n{MENUC}Количество предложений в тексте:{ENDC} {count}")
